using Microsoft.Data.Sqlite;
using NuGetDefense.Core;
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using static NuGetDefense.Core.Vulnerability;

namespace NuGetDefense;

/// <summary>
///     An initial implementation of a sqlite based cache.
/// </summary>
public class SqlLiteVulnerabilityCache
{
    public readonly string Path;

    /// <summary>
    ///     Creates anew sqlLite Cache
    /// </summary>
    /// <param name="path">Path to the sqlite sqlLite</param>
    public SqlLiteVulnerabilityCache(string path) => Path = path;

    /// <summary>
    ///     Enables/Disables the Cache
    /// </summary>
    public bool Enabled { get; set; } = true;

    public static void CreateNewSqlLiteCache(string path)
    {
        using SqliteConnection connection = CreateDbConnection(path);

        var createPackagesTableCommand = connection.CreateCommand();
        createPackagesTableCommand.CommandText = "CREATE TABLE packages(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createPackagesTableCommand.ExecuteNonQuery();

        var createVulnerabilitySourcesTableCommand = connection.CreateCommand();
        createVulnerabilitySourcesTableCommand.CommandText = @"CREATE TABLE VulnerabilitySources(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createVulnerabilitySourcesTableCommand.ExecuteNonQuery();

        var createAccessVectorTypesTableCommand = connection.CreateCommand();
        createAccessVectorTypesTableCommand.CommandText = @"CREATE TABLE AccessVectorTypes(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createAccessVectorTypesTableCommand.ExecuteNonQuery();

        foreach (var accessVectorType in Enum.GetValues(typeof(AccessVectorType)))
        {
            var insertAccessVectorTypesTableCommand = connection.CreateCommand();
            insertAccessVectorTypesTableCommand.CommandText = @$"INSERT OR IGNORE INTO AccessVectorTypes (id, name) VALUES ({(int)accessVectorType} ,'{accessVectorType}')";
            insertAccessVectorTypesTableCommand.ExecuteNonQuery();
        }

        var createVulnerabilitiesTableCommand = connection.CreateCommand();
        createVulnerabilitiesTableCommand.CommandText =
            @"CREATE TABLE Vulnerabilities(id INTEGER PRIMARY KEY, package INTEGER, cve TEXT, cwe TEXT, description TEXT, score REAL, vector INTEGER, vendor TEXT, refs TEXT, FOREIGN KEY (vector) REFERENCES AccessVectorTypes(id), FOREIGN KEY (package) REFERENCES packages(id),
                            UNIQUE (package, cve))";
        createVulnerabilitiesTableCommand.ExecuteNonQuery();

        var createPackageVersionScanCacheTableCommand = connection.CreateCommand();
        createPackageVersionScanCacheTableCommand.CommandText =
            @"CREATE TABLE PackageVersionScanCache(id INTEGER PRIMARY KEY, version TEXT, VulnerabilitySourceId INTEGER, dateLastScanned TEXT, package INTEGER, 
FOREIGN KEY(VulnerabilitySourceId) REFERENCES VulnerabilitySources(id), FOREIGN KEY (package) REFERENCES packages(id), UNIQUE (version, VulnerabilitySourceId, package))";
        createPackageVersionScanCacheTableCommand.ExecuteNonQuery();

        var createVulnerableVersionsTableCommand = connection.CreateCommand();
        createVulnerableVersionsTableCommand.CommandText =
            @"CREATE TABLE VulnerableVersions(id INTEGER PRIMARY KEY, VulnerabilityId INTEGER, CacheId INTEGER, FOREIGN KEY (CacheId) REFERENCES PackageVersionScanCache(id), FOREIGN KEY (VulnerabilityId) REFERENCES Vulnerabilities(id), UNIQUE (CacheId, VulnerabilityId));";
        createVulnerableVersionsTableCommand.ExecuteNonQuery();
    }

    /// <summary>
    ///     Checks the cache and returns a list of packages for which no valid cache is found
    /// </summary>
    /// <param name="Path">Path to sqlite cache</param>
    /// <param name="pkgs">packages to check cache for</param>
    /// <param name="maxAge">maximum age to consider a cache valid</param>
    /// <param name="cachedPackages">packages that have proper caches, ordered from oldest cache to newest</param>
    /// <param name="SourceId">Name of the Vulnerability Source that the cache is being checked for</param>
    /// <returns>List of packages that have no valid cache</returns>
    public List<NuGetPackage> GetUncachedPackages(IEnumerable<NuGetPackage> pkgs, TimeSpan maxAge, string SourceId, out NuGetPackage[] cachedPackages)
    {
        if (!Enabled)
        {
            cachedPackages = Array.Empty<NuGetPackage>();
            return pkgs.ToList();
        }

        List<NuGetPackage> uncachedPackages = new();
        List<(NuGetPackage Package, DateTime DateChecked)> datePackageTuples = new();
        foreach (var pkg in pkgs)
        {
            var connectionString = new SqliteConnectionStringBuilder
            {
                DataSource = Path
            };
            using var connection = new SqliteConnection(connectionString.ConnectionString);
            connection.Open();

            var lastCacheDateCommand = connection.CreateCommand();
            lastCacheDateCommand.CommandText = $@"Select dateLastScanned from PackageVersionScanCache 
                where package = (select id from packages where name like '{pkg.Id}') and 
                      VulnerabilitySourceId = (select Id from VulnerabilitySources where name = '{SourceId}')";

            lastCacheDateCommand.Parameters.Add(new("$SourceId", SourceId));
            lastCacheDateCommand.Parameters.Add(new("$packageName", pkg.Id));

            //TODO: Recheck all queries as sourceID has not been checked in most and needs to be upserted

            var cacheDate = (string?)lastCacheDateCommand.ExecuteScalar() ?? "01/01/0001 00:00:00";
            var dateLastChecked = DateTime.ParseExact(cacheDate, "MM/dd/yyyy HH:mm:ss", CultureInfo.InvariantCulture);


            if (dateLastChecked.Add(maxAge) < DateTime.Now) uncachedPackages.Add(pkg);
            else datePackageTuples.Add((pkg, dateLastChecked));
        }

        datePackageTuples.Sort((x, y) =>
        {
            var (_, firstDateChecked) = x;
            var (_, secondDateChecked) = y;
            return firstDateChecked == secondDateChecked ? 0 : firstDateChecked < secondDateChecked ? -1 : 1;
        });
        cachedPackages = datePackageTuples.Select(x => x.Package).ToArray();
        return uncachedPackages;
    }

    public void UpdateCache(Dictionary<string, Dictionary<string, Vulnerability>> reportedVulnerabilities, IEnumerable<NuGetPackage> updatedPkgs, string sourceName)
    {
        if (!Enabled) return;

        using SqliteConnection connection = CreateDbConnection(Path);

        using var upsertVulnerabilitySourcesCommand = connection.CreateCommand();
        upsertVulnerabilitySourcesCommand.CommandText = "INSERT OR IGNORE INTO VulnerabilitySources (name) VALUES($sourceName)";
        upsertVulnerabilitySourcesCommand.Parameters.AddWithValue("$sourceName", sourceName);
        upsertVulnerabilitySourcesCommand.ExecuteNonQuery();

        foreach (var updatedPkg in updatedPkgs)
        {
            using var upsertPackagesCommand = connection.CreateCommand();
            upsertPackagesCommand.CommandText = "INSERT OR IGNORE INTO packages (name) VALUES($packageName)";
            upsertPackagesCommand.Parameters.AddWithValue("$packageName", updatedPkg.Id.ToLower());
            upsertPackagesCommand.ExecuteNonQuery();

            using var upsertPackageVersionScanCacheCommand = connection.CreateCommand();
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$packageVersion", updatedPkg.Version.ToLower());
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$packageName", updatedPkg.Id.ToLower());
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$scanDate", DateTime.UtcNow.ToString(CultureInfo.InvariantCulture));
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$sourceName", sourceName);
            upsertPackageVersionScanCacheCommand.CommandText = @"INSERT INTO PackageVersionScanCache(version, VulnerabilitySourceId, dateLastScanned, package)
                 VALUES($packageVersion, (Select id from VulnerabilitySources where name = $sourceName), $scanDate, (select Id from packages where name = $packageName)) ON CONFLICT(version, VulnerabilitySourceId, package) DO UPDATE SET dateLastScanned = $scanDate";
            upsertPackageVersionScanCacheCommand.ExecuteNonQuery();
        }

        if (reportedVulnerabilities is null) return;

        foreach (var (packageUrl, vulnerabilities) in reportedVulnerabilities)
        {
            var packageName = packageUrl.Substring(10, packageUrl.Length - 10 - packageUrl.Substring(packageUrl.IndexOf('@')).Length);
            var packageVersion = packageUrl[(packageUrl.IndexOf('@') + 1)..];

            foreach (var (_, vulnerability) in vulnerabilities)
            {
                using var insertAccessVectorTypesTableCommand = connection.CreateCommand();
                insertAccessVectorTypesTableCommand.Parameters.AddWithValue("$cve", vulnerability.Cve);
                insertAccessVectorTypesTableCommand.CommandText = @$"INSERT OR IGNORE INTO AccessVectorTypes (id, name) VALUES ({(int)vulnerability.Vector} ,'{vulnerability.Vector}')";
                insertAccessVectorTypesTableCommand.ExecuteNonQuery();

                using var upsertVulnerabilitiesCommand = connection.CreateCommand();
                var vector = 
                upsertVulnerabilitiesCommand.CommandText = @"
                    INSERT INTO Vulnerabilities (package, cve, cwe, description, score, vector, vendor, refs)
                    VALUES((SELECT Id FROM Packages WHERE name = $packageName), $cve, $cwe, $description, $score, $vector, $vendor, $refs)
                    ON CONFLICT DO UPDATE SET cve = $cve, cwe = $cwe, description = $description, score = $score, vector = $vector, refs = $refs
";
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$packageName", packageName);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$cve", vulnerability.Cve);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$cwe", vulnerability.Cwe ?? "");
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$description", vulnerability.Description);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$score", vulnerability.CvssScore);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$vector", (int)vulnerability.Vector);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$vendor", vulnerability.Vendor);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$refs", string.Join(' ', vulnerability.References));
                upsertVulnerabilitiesCommand.ExecuteNonQuery();

                using var upsertVulnerableVersionsCommand = connection.CreateCommand();
                upsertVulnerableVersionsCommand.CommandText = @"INSERT OR IGNORE INTO VulnerableVersions (VulnerabilityId, CacheId) 
                    VALUES((SELECT Id FROM Vulnerabilities WHERE package = (SELECT Id FROM Packages WHERE name = $packageName) AND cve = $cve), 
                           (SELECT Id FROM PackageVersionScanCache WHERE package = (SELECT Id FROM Packages WHERE name = $packageName) 
                            AND VulnerabilitySourceId = (Select id from VulnerabilitySources where name = $sourceName)
                            AND version = $version))";
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$packageName", packageName);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$sourceName", sourceName);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$version", packageVersion);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$cve", vulnerability.Cve);
                upsertVulnerableVersionsCommand.ExecuteNonQuery();
            }
        }
    }

    public void GetPackagesCachedVulnerabilitiesForSource(IEnumerable<NuGetPackage> cachedPackages, string sourceName,
        ref Dictionary<string, Dictionary<string, Vulnerability>> vulnDict)
    {
        if (!Enabled) return;

        foreach (var cachedPkg in cachedPackages) GetPackageCachedVulnerabilitiesForSource(cachedPkg, sourceName, ref vulnDict);
    }


    public void GetPackageCachedVulnerabilitiesForSource(NuGetPackage package, string sourceName,
        ref Dictionary<string, Dictionary<string, Vulnerability>> packageUrlVulnerabilityMap)
    {
        if (!Enabled) return;

        using SqliteConnection connection = CreateDbConnection(Path);

        using var command = connection.CreateCommand();
        command.CommandText =
            $@"SELECT cve, cwe, description, score, vector, vendor, refs FROM vulnerabilities WHERE id IN
                    (SELECT VulnerabilityId FROM VulnerableVersions WHERE CacheId IN 
                        (SELECT id FROM PackageVersionScanCache WHERE package = (Select Id from Packages where name = '{package.Id.ToLower()}') AND version = '{package.Version.ToLower()}' AND VulnerabilitySourceId IN
                            (SELECT id FROM VulnerabilitySources WHERE name = '{sourceName}')))";
        command.Parameters.AddWithValue("$packageName", package.Id.ToLower());
        command.Parameters.AddWithValue("$version", package.Version.ToLower());
        command.Parameters.AddWithValue("$sourceName", sourceName);

        packageUrlVulnerabilityMap ??= new();
        var vulnerabilities = new List<Vulnerability>();
        using var reader = command.ExecuteReader();

        while (reader.Read())
        {
            vulnerabilities.Add(
                new(
                    (string)reader["cve"],
                    (double)reader["score"],
                    (string)reader["cwe"],
                    (string)reader["description"],
                    ((string)reader["refs"]).Split(' '),
                    Enum.Parse<AccessVectorType>(((long)reader["vector"]).ToString()),
                    (string)reader["vendor"]
                )
            );
        }

        // No vulnerabilities in cache for this package url
        if (vulnerabilities.Count == 0) return;

        // Allocate storage for vulnerabilities if required
        if (!packageUrlVulnerabilityMap.ContainsKey(package.PackageUrl))
        {
            packageUrlVulnerabilityMap.Add(package.PackageUrl, new());
        }

        // Add / Update vulnerability
        foreach (var vulnerability in vulnerabilities)
        {
            var container = packageUrlVulnerabilityMap[package.PackageUrl];
            container[vulnerability.Cve] = vulnerability;
        };
    }

    private static SqliteConnection CreateDbConnection(string path)
    {
        var connectionString = new SqliteConnectionStringBuilder
        {
            DataSource = path
        };
        var connection = new SqliteConnection(connectionString.ConnectionString);
        connection.Open();
        return connection;
    }

}